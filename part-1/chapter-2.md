### Глава 2. Модель предметной области

Эта глава охватывает:

* Извлечение объекта и репозитория из кода взаимодействия с базой данных.
* Использование объекта для защиты модели от противоречивых данных.
* Сопоставление объекта с таблицей базы данных внутри реализации репозитория.
* Предоставление сущности идентификатора перед ее сохранением.

### 2.1 Операторы SQL повсюду

В этой главе мы работаем с воображаемым веб-приложением, которое позволяет пользователям просматривать каталог
электронных книг, выбирать одну и заказывать ее. Это устаревшее приложение, которое становится трудно поддерживать.
Трудно понять, что делает код, с какими концепциями он имеет дело и какие бизнес-правила применимы. Кроме того, никто не
писал тесты, потому что для такого кода их писать сложно. Давайте взглянем на код, запускаемый нашим приложением, когда
пользователь выбирает электронную книгу из нашего каталога и заказывает ее (см. листинг 2.1).

<b>Листинг 2.1:</b> Исходный метод orderEbookAction().

```php
public function orderEbookAction(Request $request): Response
{
    $connection = $this−>container−>get('connection');
    $ebookPrice = $connection−>execute(
        'SELECT price FROM ebooks WHERE id = :id',
        [
            'id' => $request−>request−>get('ebook_id')
        ]
    )−>fetchColumn(0);
    $orderAmount = (int)$request−>get('quantity') * (int)$ebookPrice;
    $record = [
        'email' => $request−>get('email_address'),
        'quantity' => (int)$request−>get('quantity'),
        'amount' => $orderAmount,
    ];
    $columns = array_keys($record);
    $values = array_map(
        fn ($value) => $connection−>escape($value),
        array_values($record)
    );
    $sql = 'INSERT INTO orders ('. implode(', ', $columns). ') VALUES (' . implode(', ', $values) . ')';
    $connection−>execute($sql);
    $lastInsertedId = $connection−>execute('SELECT LAST_INSERT_ID()')−>fetchColumn(0);
    $this−>container−>get('session')−>set('currentOrderId', $lastInsertedId);
    // ...
}

return new Response(/* ... */);
```

Если вы умеете читать между строк (и видеть сквозь операторы SQL), вы научитесь нескольким вещам. Как пользователь вы
можете заказать электронную книгу по ее ID. Вы должны указать свой адрес электронной почты, и ваш заказ будет сохранен
как запись в таблице заказов. Сама таблица заказов имеет автоматически увеличивающийся столбец идентификатора. После
вставки новой записи в таблицу заказов контроллер извлекает для нее автоматически назначенный идентификатор и сохраняет
его в сессии.

Вам уже может быть очевидно, что это плохой код. Тем не менее, я кратко упомяну здесь недостатки:

1. Очень сложно узнать, какова история или сценарий этого действа. Что влечет за собой вариант использования заказа
   электронной книги? Какие шаги задействованы? Каков результат?

2. Детали реализации скрывают представление об этапах сценария более высокого уровня. Например, одним из шагов будет
   сохранение нового заказа. Однако в коде не говорится «порядок сохранения». Он просто показывает, как выполняется это
   сохранение. Мы должны проанализировать оператор SQL и заметить, что это оператор INSERT, из которого мы можем
   вывести, что это код для сохранения нового заказа.

3. Сочетание высокоуровневых шагов с низкоуровневыми деталями реализации напрямую связывает сам вариант использования с
   любыми связанными технологическими решениями. Это очень затрудняет изменение направления позже. Например, нам было бы
   трудно мигрировать на другую базу данных. Нам также было бы трудно заменить веб-форму JSON API для этого варианта
   использования.

В этой главе мы сосредоточимся на второй проблеме. Мы хотим сохранить заказ в один шаг и скрыть детали
того, как именно это делается. В главах 3 и 4 мы будем работать над оставшимися вопросами.

### 2.2 Попытка исправить это с помощью шлюза табличных данных

Традиционным решением для вынесения операторов SQL за пределы обычного кода является использование шаблона
проектирования Table Data Gateway (или сокращенно Table Gateway) (Martin Fowler, “Patterns of Enterprise Application
Architecture", Addison-Wesley Professional
(2003)). Он скрывает операторы SQL и другие детали реализации
за единым интерфейсом для каждой таблицы базы данных. В листинге 2.2 показано, как выглядит действие контроллера, когда
мы начинаем использовать табличные шлюзы.

<b>Листинг 2.2:</b> orderEbookAction использует шлюзы таблиц для взаимодействия с базой данных.

```php
public function orderEbookAction(Request $request): Response
{
    $ebooksGateway = $this−>container−>get('ebooks_gateway');
    $ebookPrice = $ebooksGateway−>select(
        [
            'id' => $request−>request−>get('ebook_id')
        ]
    )[0]['price'];
    $orderAmount = (int)$request−>get('quantity') * (int)$ebookPrice;
   
    $ordersGateway = $this−>container−>get('orders_gateway');
    $lastInsertedId = $ordersGateway−>insert(
        [
            'email' => $request−>get('email_address'),
            'quantity' => (int)$request−>get('quantity'),
            'amount' => $orderAmount
        ]
    );
    $this−>container−>get('session')−>set('currentOrderId', $lastInsertedId);
}

return new Response(/* ... */);
```

Метод стал намного короче. В нашем обычном коде больше нет операторов SQL. При его чтении нам не нужно так часто
переключать контексты, поэтому определенно легче понять, что происходит. Тем не менее, нам удалось исправить только
половину исходной проблемы. Мы смогли скрыть только некоторые детали реализации (имена таблиц, SQL-запросы), но оставили
другие детали реализации внутри действия контроллера (имена и типы столбцов). Это оставляет нас все еще очень
привязанными к технологическим решениям, которые мы приняли для этого фрагмента кода: код остается в значительной
степени ориентированным на таблицы, поэтому мы застряли на использовании реляционной базы данных.

Предлагая общие
манипуляции с таблицами, как это делает шлюз таблиц, мы обнаруживаем еще одну проблему, которую мы еще не заметили, но
которая существовала с самого начала. Ничто не мешает нам вставить в столбец электронной почты строку, которая даже не
выглядит как адрес электронной почты. Шлюз таблиц также не мешает нам неправильно рассчитать сумму заказа и вставить ее
прямо в базу данных. Другими словами: мы не можем защитить внутреннюю согласованность данных заказа электронной книги.

### 2.3 Проектирование сущности

Мы хотим принять заказ клиента на электронную книгу и запомнить его, чтобы потом обработать. Поэтому перед сохранением
заказа мы должны убедиться, что он полный и правильный. Если мы этого не сделаем, нам, возможно, даже придется связаться
с нашими клиентами впоследствии и попросить их исправить данные, которые мы получили от них. Мы также хотим убедиться,
что то, что попадает в базу данных, может безопасно использоваться другими частями приложения, например модулем оплаты
или модулем выполнения, который отправит электронную книгу покупателю. Нам повезло, что мы занимаемся
объектно-ориентированным программированием, потому что с помощью объектов мы можем достичь всех наших целей. Когда
объект создается, он может принимать данные в качестве аргументов конструктора, анализировать эти данные и генерировать
исключения, когда какая-либо его часть выглядит неправильно или приводит к тому, что объект оказывается в
несогласованном или неполном состоянии. В нашем случае мы бы определили класс Order (см. листинг 2.3), который благодаря
наличию параметров конструктора может заставить своего создателя предоставить все необходимые данные сразу.

```php
final class Order 
{
    private int $ebookId;
    private string $emailAddress;
    private int $quantityOrdered;
    private int $pricePerUnitInCents;
    private int $orderAmountInCents;
    
    public function __construct(
        int $ebookId,
        string $emailAddress,
        int $quantityOrdered,
        int $pricePerUnitInCents,
        int $orderAmountInCents
    ) {
        $this−>ebookId = $ebookId;
        $this−>emailAddress = $emailAddress;
        $this−>quantityOrdered = $quantityOrdered;
        $this−>pricePerUnitInCents = $pricePerUnitInCents;
        $this−>orderAmountInCents = $orderAmountInCents;
    }
}

// Клиент должен предоставить все необходимые аргументы:
$order = new Order(/* ... */);
```

Принуждение клиентов к предоставлению ряда аргументов при создании экземпляра класса Order недостаточно для обеспечения
согласованности. Информация, которую предоставляют клиенты, все еще может быть недействительной или бессмысленной.
Например, текущая реализация не помешает вам создать экземпляр Order следующим, заведомо недопустимым способом: new
Order(-10, 'foobar', 0, 1000000, 25). Мы можем улучшить конструктор, выполнив некоторые базовые проверки внутри него,
используя утверждения из одной из доступных библиотек утверждений (например, _**beberlei/assert**_ ) или используя
нативные
утверждения 9, если хотите. См. листинг 2.4, в котором показано, как можно использовать предопределенные функции
утверждений для предотвращения присвоения неверных данных свойствам экземпляра Order.

**Листинг 2.4.** Сущность Order проверяет аргументы своего конструктора с помощью утверждений.

```php
use Assert\Assertion;

final class Order 
{
    private int $ebookId;
    private string $emailAddress;
    private int $quantityOrdered;
    private int $pricePerUnitInCents;
    private int $orderAmountInCents;
    
    public function __construct(
        int $ebookId,
        string $emailAddress,
        int $quantityOrdered,
        int $pricePerUnitInCents,
        int $orderAmountInCents
    ) {
        Assertion::greaterThan($ebookId, 0);
        Assertion::email($emailAddress);
        Assertion::greaterThan($quantityOrdered, 0);
        Assertion::greaterThan($pricePerUnitInCents, 0);
        Assertion::greaterThan($orderAmountInCents, 0);
        
        $this−>ebookId = $ebookId;
        $this−>emailAddress = $emailAddress;
        $this−>quantityOrdered = $quantityOrdered;
        $this−>pricePerUnitInCents = $pricePerUnitInCents;
        $this−>orderAmountInCents = $orderAmountInCents;
    }
}

// Клиент должен предоставить все необходимые аргументы:
$order = new Order(/* ... */);
```

Код в Assertion::greaterThan() вызовет исключение, если $ebookId равен 0 или меньше. Аналогично, если $emailAddress
является строкой, но не выглядит как адрес электронной почты, будет выдано исключение. Таким образом, эти утверждения
предотвратят создание экземпляра объекта Order с недопустимыми данными. Имея эти утверждения, объект Order может
обеспечить базовую согласованность данных, которые он содержит.

«Можем ли мы использовать эти функции утверждения для проверки пользовательского ввода?»

Если пользователь вводит неправильный адрес электронной почты, мы, вероятно, захотим показать красивое и понятное
сообщение об ошибке рядом с полем формы электронной почты, где пользователь его указал. С текущей версией нашей сущности
Order мы бы не смогли этого сделать, потому что вызов Assertion::email() со строкой, не похожей на адрес электронной
почты, вызовет исключение. Если вы где-то не поймаете это исключение, оно просто покажет страницу ошибки приложения по
умолчанию с некоторым общим сообщением, например «К сожалению, произошла ошибка». Вкратце: утверждения не будут очень
полезны, когда нам нужно проверить ввод пользователя. Вместо этого они должны использоваться объектами как способ защиты
от неполных, противоречивых или бессмысленных данных. Когда дело доходит до возражений пользователю, информирования его
об его ошибках, следует искать альтернативы. Мы обсудим некоторые из них в главе 8.

Объект с состоянием, который гарантирует собственную согласованность и будет каким-то образом сохраняться, часто
называют Entity (Eric Evans, “Domain-Driven Design”, Addison-Wesley Professional (2003)). Сущности по определению имеют
идентификатор, который мы можем использовать, чтобы сохранить его и
снова получить из хранилища. Несмотря на то, что у нашего Order еще нет идентификатора (ID), мы собираемся присвоить
ему идентификатор в Разделе 2.6, поэтому давайте будем считать, что Order уже является сущностью.

Мы почти готовы использовать новый экземпляр Order в действии контроллера. Есть одна вещь, которая мешает нам сделать
это: шлюз таблиц для заказов имеет метод insert(), который принимает массив столбцов => значений (см. листинг 2.5). Но
теперь, когда мы передаем данные формы конструктору Order, у нас больше нет такого массива внутри контроллера. Мы могли
бы добавить его обратно, но избавление от фактических имен столбцов внутри действия контроллера уже было в нашем списке
улучшений, поэтому мы не должны этого делать.

**Листинг 2.5.** Чтобы сохранить сущность Order с помощью шлюза таблицы, нам по-прежнему требуется сопоставление
столбцов со значениями.

```php
public function orderEbookAction(Request $request): Response
{
    // ...
    // Мы хотели бы использовать новую сущность Order...
    $order = new Order(
        $request−>get('ebook_id'),
        $request−>get('email_address'),
        (int)$request−>get('quantity'),
        (int)$pricePerUnitInCents,
        (int)$orderAmount
    );
    
    // Но как сохранить объект Order в базу данных?
    $ordersGateway = $this−>container−>get('orders_gateway');
    $lastInsertedId = $ordersGateway−>insert(
        [
            // Нам нужна карта столбец => значение
        ]
    );
}
// ...
```

То, что мы хотим сохранить (объект Order), и то, что может его сохранить (OrdersGateway), оказываются несовместимыми. Но
мы
все равно хотим каким-то образом сохранить объект Order в базу данных, поэтому нам нужно найти другой дизайн для того,
что может это сделать.

### 2.4 Знакомство с репозиторием

Если какое-то средство еще недоступно в проекте, вы можете применить хитрость программирования: действовать так, как
если бы оно уже было доступно. Например, если вы ищете вещь, которая может сохранять Order в базу данных, просто
представьте, что эта вещь уже существует, и начните ее использовать (см. листинг 2.6).

**Листинг 2.6:** Воображаемый объект для сохранения заказов.

```php
$order = new Order(/* ... */);
$lastInsertedId = $orderSaver−>save($order);
```

Чтобы быть полезным для нас в этом месте, вещь, которая может сохранить заказ, нуждается только в методе save() с одним
параметром типа Order. Так как база данных определяет идентификатор нового заказа, используя автоматически
увеличивающийся столбец целых чисел, мы могли бы присвоить этому методу тип возвращаемого значения int, чтобы клиент
метода мог позже использовать вновь назначенный идентификатор. Давайте формализуем все это, определив интерфейс для
нашего «сохранителя заказов» (см. листинг 2.7).

**Листинг 2.7:** Интерфейс OrderSaver.

```php
interface OrderSaver
{
    /**
    * @return int
    */
    public function save(Order $order): int; //вернет ID сохраненного «Заказа»
}
```

'Сохранители объектов' обычно называют репозиториями. Репозиторий — это название шаблона проектирования, который
обеспечивает решение общей
проблемы: необходимость сохранить объект предметной области, а затем воссоздать его. Чтобы было ясно, что мы намерены
использовать здесь шаблон проектирования репозитория11, давайте переименуем OrderSaver в OrderRepository (см. листинг
2.8).

**Листинг 2.8:** Интерфейс OrderRepository.

```php
interface OrderRepository
{
    /**
    * @return int
    */
    public function save(Order $order): int;
}
```

«Разве у нас не должен быть метод getById()?»

Помимо сохранения объекта, репозиторий обычно предлагает способ извлечения
ранее сохраненного объекта из базы данных. Обычно репозиторий имеет метод getById(), который позволяет клиентам делать
это:

```php
interface OrderRepository
{
    public function save(Order $order): void;

    /**
    * @throws CouldNotFindOrder
    */
    public function getById(int $orderId): Order;
}
```

Клиент предоставляет идентификатор сущности, которую он хочет получить, а репозиторий берет данные для соответствующего
заказа из базы данных и, наконец, формирует весь объект сущности, используя эти данные. Если репозиторий не может
найти заказ с предоставленным идентификатором, он выдает пользовательское исключение (например, CouldNotFindOrder),
которое наследуется от RuntimeException. Поскольку мы рефакторим существующий код только для одного контроллера, я не
хотел сразу предлагать добавлять метод getById() в OrderRepository, но когда придет время, полезно знать, что у save()
есть симметричный аналог, называемый getById().

В контроллере теперь все становится намного чище (см. листинг 2.9). Мы можем создать экземпляр нового объекта Order и
передать его в OrderRepository, который затем сохранит его в базе данных. Предполагая, что мы можем каким-то образом
получить работающий экземпляр OrderRepository из нашего сервисного контейнера, т.е.

**Листинг 2.9:** метод orderEbookAction() теперь использует OrderRepository и сущность Order.

```php
public function orderEbookAction(Request $request): Response
{
    $order = new Order(/* ... */);
    $orderRepository = $this−>container−>get('order_repository');
    $lastInsertedId = $orderRepository−>save($order);
}
```

### 2.5 Сопоставление данных сущности со столбцами таблицы

До сих пор мы работали с интерфейсом OrderRepository, который на данный момент не имеет реализации. Написание
реализации, которая фактически сохраняет Order в базу данных, может оказаться не такой простой задачей, как хотелось бы.
Как видно из листинга 2.10, в какой-то момент нам все еще понадобится этот массив столбцов => значений, которого у нас
больше нет.

```php
final class SqlOrderRepository implements OrderRepository
{
    private Connection $connection;
    
    public function __construct(Connection $connection)
    {
        $this−>connection = $connection;
    }
    public function save(Order $order): int
    {
        $data = [
        // Опять же, нам нужен массив столбцов => значения
        ];
        $columns = array_keys($data);
        $values = array_map(
            fn ($value) => $this−>connection−>escape($value),
            array_values($data)
        );
        $sql = 'INSERT INTO orders ('. implode(', ', $columns). ') VALUES (' . implode(', ', $values) . ')';
        $this−>connection−>execute($sql);
        $lastInsertedId = $this−>connection−>execute('SELECT LAST_INSERT_ID();')−>fetchColumn(0);
        
        return $lastInsertedId;
    }
}
```

Здесь есть разные варианты. Наиболее распространенным является установка ORM в вашем проекте, которая может выполнять
сопоставление свойств объекта со столбцами таблицы за вас.

### 2.5.1 Использование ORM

В разделе 2.8 мы поговорим о том, какой тип ORM лучше всего работает в этом сценарии. А пока давайте рассмотрим пример с
использованием популярной Doctrine ORM. После того, как мы установили Doctrine ORM в наш проект и настроили соединение
с базой данных, нам сначала нужно добавить конфигурацию сопоставления к классу сущности и его свойствам. В листинге 2.11
показано, как это сделать с помощью аннотаций.

**Листинг 2.11:** Использование аннотаций для настройки отображения.

```php
use Doctrine\ORM\Mapping as ORM;

/**
* @ORM\Entity
* @ORM\Table(name="orders")
*/
final class Order
{
    /**
    * @ORM\Id
    * @ORM\GeneratedValue
    * @ORM\Column(type="integer")
    */
    private int $id;
    /**
    * @ORM\Column(type="string")
    */
    private string $emailAddress;
    /**
    * @ORM\Column(type="int")
    */
    private int $quantityOrdered;
    /**
    * @ORM\Column(type="int")
    */
    private int $pricePerUnitInCents;
}
// ...
```

На основе аннотаций Doctrine должна иметь возможность сохранять данные объекта в нужных таблице и столбцах. Теперь мы
можем написать очень простую реализацию интерфейса OrderRepository, которая использует EntityManager Doctrine для
сохранения объектов Order (см. листинг 2.12).

**Листинг 2.12:** Реализация OrderRepository с использованием Doctrine ORM.

```php
use Doctrine\ORM\EntityManagerInterface;

final class OrderRepositoryUsingDoctrineOrm implements OrderRepository
{
    private EntityManagerInterface $entityManager;
    
    public function __construct(EntityManagerInterface $entityManager)
    {
        $this−>entityManager = $entityManager;
    }

    public function save(Order $order): void
    {
        $this−>entityManager−>persist($order);
        $this−>entityManager−>flush();
    }
}
```

Как видно из этого примера кода, установка и использование ORM для сохранения объекта в базе данных не требует больших
усилий. И да, это может сэкономить вам время и, возможно, много строк кода, но также может привести к проблемам. Лично я
потратил много времени, пытаясь понять, как или почему что-то не работает, или почему Doctrine вдруг пришлось выполнять
так много запросов. Также не раз случалось, что я обнаруживал, что что-то сломалось, когда оно уже работало в
продакшене. Проблема заключается не в самой Doctrine ORM, а в использовании общих абстракций. Пряча столько деталей
реализации и столько «магии» за одним абстрактным интерфейсом EntityManagerInterface, вы рано или поздно столкнетесь с
проблемами. Сказав это, есть также несколько преимуществ использования популярной ORM, например:

1. Обширная документация, онлайн-примеры, сообщения в блогах, вопросы и ответы на StackOverflow и т.д.
2. Автоматизированные решения общих проблем, таких как миграция базы данных, загрузка фикстур и т. д.

По моему опыту, можно использовать ORM, если вы можете придерживаться следующих правил:

1. Используйте только простую конфигурацию сопоставления; без наследования таблиц, «встраиваемых модулей»,
   пользовательских типов и т. д.13
2. Придерживайтесь ассоциаций «один ко многим».
3. Ссылайтесь на объекты по их ID.
4. Не переходите от объекта к объекту, используя поля ассоциации.

Не случайно эти правила имеют много общего с правилами **«effective aggregate design»**, описанными **Вон
Верноном**. Мы вернемся к этой теме в разделе 11.2.

Как Doctrine может получить данные из сущности? Он использует **рефлексию**, чтобы добраться до объекта, скопировать
данные из частных свойств объекта и подготовить нужный массив, используя эти данные.

В листинге 2.13 показано, как это будет выглядеть, если мы встроим код отображения в наш собственный метод save().

**Листинг 2.13:** Реализация save(), использующая рефлексию.

```php
public function save(Order $order): int
{
    // ...
    $data = [];
    $object = new ReflectionObject($order);
    $emailProperty = $object−>getProperty('emailAddress');
    
    // Сделать приватное свойство доступным:
    $emailProperty−>setAccessible(true);
    
    // Получить текущее значение свойства emailAddress:
    $data['email'] = $emailProperty−>getValue($order);
    
    // И так далее, для всех свойств Order...
}
// ...
```

### 2.5.2 Ручное сопоставление

Хотя это здорово, что Doctrine может сделать всю эту работу за нас, мы не видим, как она это делает. И это причина того,
что будет трудно выяснить, в чем проблема, когда что-то работает не так, как ожидалось. За последние несколько лет я не
раз приходил к выводу, что сделать маппинг вручную, то есть самому написать для этого код, может быть довольно хорошим
решением. В этом случае мы можем, но не обязаны использовать рефлексию, и нам не нужна отдельная конфигурация
сопоставления (с использованием аннотаций, XML и т. д.). Есть два варианта реализации: либо вы позволяете объекту
подготовить массив столбцов => значений, либо вы позволяете ему предоставлять свои внутренние данные в виде массива и
выполнять сопоставление внутри репозитория. В листинге 2.14 показан пример первого варианта.

**Листинг 2.14:** save() извлекает сопоставленные данные из объекта Order.

```php
final class Order
{
    // ...
    public function mappedData(): array
    {
        return [
            'email' => $this−>emailAddress,
            'quantity' => $this−>quantityOrdered,
            // ...
        ];
    }
}

final class SqlOrderRepository implements OrderRepository
{
    // ...
    public function save(Order $order): int
    {
        // ...
        $data = $order−>mappedData();
        // $data is an array of columns => values
    }
}
// ...
```

Недостатком этого подхода является то, что сущность Order знает имена и типы столбцов базы данных. Всякий раз, когда
столбец переименовывается, вам также придется обновлять класс Order. В листинге 2.15 показан альтернативный вариант,
когда объект предоставляет только свои внутренние данные, а репозиторий сам выполняет сопоставление.

**Листинг 2.15:** save() выполняет сопоставление со столбцами базы данных.

```php
final class Order
{
    public function internalData(): array
    {
        return get_object_vars($this);
    }
}

final class SqlOrderRepository implements OrderRepository
{
    // ...
    public function save(Order $order): int
    {
        // ...
        $internalData = $order−>internalData();
        $data = [
            'email' => $internalData['emailAddress'],
            'quantity' => $internalData['quantityOrdered'],
        // ...
        ];
    }
    // ...
}
```

Недостатком этого подхода является то, что он снижает уровень инкапсуляции Order. SqlOrderRepository должен знать о
частных свойствах Order: сколько есть свойств, каковы их имена и типы. Всякий раз, когда вы переименовываете свойство,
меняете его тип, добавляете или удаляете свойства, вам также придется обновить соответствующий код сопоставления в
SqlOrderRepository. Я предпочитаю, чтобы Order хранил имена и типы своих внутренних свойств при себе. Будет очень сложно
провести рефакторинг объекта Order, если его внутренние компоненты перестанут быть приватными. Возможность свободно
изменять внутреннюю структуру объекта — это то, что позволяет улучшить его дизайн. Так что для меня раскрытие имен
приватных свойств — слишком высокая цена, и мы должны выбрать первый вариант: позволить объекту самому сделать
сопоставление.

Я уже писал об этой теме, связанных с этим компромиссом и различных вариантах реализации.
См.: [«ORMless; a Memento-like pattern for object persistence»](https://matthiasnoback.nl/2018/03/ormless-a-memento-like-pattern-for-object-persistence/)
.

«Теперь у нас есть имена столбцов внутри объекта… Разве это не приводит к нездоровому сочетанию инфраструктуры и
основного кода?»

Отличный вопрос, с тонким ответом.

Чтобы продемонстрировать, что наличие имен столбцов внутри класса сущностей не превращает его автоматически в код
инфраструктуры, давайте еще раз проверим правила.

1. Основной код не зависит напрямую ни от внешних систем, ни от кода, написанного для взаимодействия с конкретным типом
   внешней системы.

2. Основной код не нуждается в определенной среде для запуска и не имеет зависимостей, предназначенных для работы только
   в определенном контексте. Взгляните на метод mappedData():

```php
final class Order
{
    // ...
    public function mappedData(): array
    {
        return [
            'email' => $this−>emailAddress,
            'quantity' => $this−>quantityOrdered,
            // ...
        ];
    }
}
```

При вызове mappedData() внешние системы, такие как база данных, не должны быть доступны. На самом деле код в этом методе
вообще не имеет зависимостей. Метод mappedData() может работать в любом контексте без какой-либо специальной настройки.
Он не требует специальной настройки: вы можете создать экземпляр объекта Order обычным способом и вызвать этот метод
mappedData(). Этот код также не имеет зависимостей, предназначенных для работы в определенном контексте. Таким образом,
mappedData() соответствует обоим правилам для основного кода. Разве это не может быть основным кодом; он выполняет
только
некоторые простые преобразования значений в памяти.

Как насчет добавления аннотаций сопоставления Doctrine к вашей
сущности, таких как @Entity, @Table и @Column? Это приводит к смешанному коду? Что ж, создание экземпляра объекта с
аннотациями сопоставления не требует специальной настройки. И вызов любого метода на нем не требует наличия внешних
зависимостей. Поэтому, если ваша сущность готова к сохранению с помощью Doctrine, ее все равно следует считать кодом
ядра, а не кодом инфраструктуры.

Однако объект с аннотациями Doctrine или методом mappedData() содержит детали
технической реализации (например, имена таблиц и столбцов и типы столбцов). Поэтому, когда вы все-таки дойдете до того,
что захотите переключить базы данных, вам все равно придется изменить этот код. Для меня это не причина перемещать код
сопоставления за пределы сущности. В частности, потому что так удобно держать свойства объекта и код сопоставления
близко друг к другу.

### 2.6 Генерация идентификатора для нового объекта

Давайте еще раз взглянем на код контроллера, каким он был после того, как мы начали использовать сущность Order и
OrderRepository (см. листинг 2.16).

**Листинг 2.16:** Текущее состояние orderEbookAction().

```php
public function orderEbookAction(Request $request): Response
{
    $order = new Order(/* ... */);
    $orderRepository = $this−>container−>get('order_repository');
    $lastInsertedId = $orderRepository−>save($order);
}
```

Внедрив интерфейс OrderRepository, нам удалось скрыть большую часть деталей реализации, связанных с сохранением заказов.
Остался только один. ID Заказа, который мы создаем, является целым числом. Его значение будет известно нам только тогда,
когда OrderRepository сохранит заказ, поэтому это целое число является возвращаемым значением его метода save(). Это
по-прежнему показывает читателю кода, что механизм, используемый для сохранения заказа, использует автоинкрементный
целочисленный столбец для основного идентификатора заказа.

Это не обязательно плохо, если объект раскрывает часть своей внутренней работы, хотя мы обычно стараемся этого избегать.
Настоящая проблема здесь в том, что мы все еще не в состоянии полностью заменить базовую технологию хранения. Не каждая
база данных поддерживает автоинкремент столбцов или полей ID. Не каждая база данных сможет сгенерировать идентификатор и
вернуть его. И в самом крайнем случае: некоторые механизмы персистентности могут даже не иметь возможности синхронно
возвращать идентификатор клиенту.

Другая проблема заключается в том, что объект Order должен быть завершен с самого начала. Он должен содержать
минимальный набор данных, чтобы быть полезным и последовательным в своем поведении. Учитывая, что у заказа нет
идентификатора до тех пор, пока он не будет сохранен, мы должны прийти к противоположному выводу: заказ не является
согласованным, пока база данных не закончит его сохранение.

Вместо этого мы хотели бы предоставить Order идентификатор в момент его создания. Этого можно добиться, добавив его в
качестве обязательного аргумента конструктора. Таким образом мы можем убедиться, что объект Order всегда имеет
идентификатор (см. листинг 2.25).

**Листинг 2.17:** Order теперь имеет идентификатор с самого начала.

```php
final class Order
{
    private int $id;
    //...
    
    public function __construct(int $id)
    {
        $this−>id = $id;
        //...
    }
    
    //...
}
```

Затем клиенты должны будут предоставить идентификатор заранее, когда они хотят создать новый Заказ. Но как клиент может
узнать, какой следующий доступный идентификатор? Учитывая, что OrderRepository близок к источнику этих знаний, а именно
к самой таблице заказов, давайте дадим ему новый метод, который может ответить на этот вопрос, и назовем его
nextIdentity() (см. листинг 2.18).

**Листинг 2.18:** nextIdentity() возвращает следующий доступный идентификатор.

```php
interface OrderRepository
{
    public function nextIdentity(): int;
    
    //...
}
```

Возможная реализация метода nextIdentity() может быть показана в листинге 2.19. Он выбирает самый высокий идентификатор,
используемый в настоящее время, и возвращает следующее число, которое, следовательно, будет следующим доступным
идентификатором.

**Листинг 2.19:** Простая реализация nextIdentity().

```php
final class SqlOrderRepository implements OrderRepository
{
    // ...
    public function nextIdentity(): int
    {
        return (int) $this−>connection−>execute('SELECT MAX(id) AS highestId FROM orders')−>fetchColumn(0) + 1;
    }
}
```

Возможно, вы уже заметили проблему: если приложение имеет много одновременных пользователей, есть вероятность, что два
клиента в конечном итоге попытаются вставить запись с одним и тем же идентификатором. Если параллелизм обычно не
является для вас проблемой, данная реализация может быть правильной. Если у вас начинаются проблемы с
параллелизмом или они уже есть, вы можете переключиться на более надежную реализацию, например ту, которая использует
последовательность (sequence) на уровне базы данных. Если ваша база данных не поддерживает последовательности, написать
код
самостоятельно не составит большого труда. Пример реализации см. в листинге 2.20.

**Листинг 2.20:** Эта версия nextIdentity() использует таблицу последовательностей.

```php
public function nextIdentity(): int
{
    return $this−>connection−>transactional(function () {
        $nextId = (int) $this−>connection−>execute('SELECT last_id FROM order_id_sequence')−>fetchColumn(0) + 1;
        $this−>connection−>execute(
        'UPDATE order_id_sequence SET last_id = :last_id',
            [
                'last_id' => $nextId
            ]
        );
        
        return $nextId;
    });
}
```

Как только мы добавили подходящую реализацию nextIdentity(), нам больше не нужно ждать, пока база данных вернет нам
автоматически увеличивающееся значение идентификатора. Вместо этого теперь, когда сущность Order уже содержит свой
идентификатор с самого начала, мы должны использовать этот идентификатор при сопоставлении данных сущности со столбцами
в базе данных (см. листинг 2.21).

**Листинг 2.21:** mappedData() также возвращает значение для столбца id.

```php
final class Order
{
    // ...
    public function mappedData(): array
    {
        return [
            'id' => $this->id,
            'email' => $this−>emailAddress,
            'quantity' => $this−>quantityOrdered,
            // ...
        ];
    }
}
```

В контроллере теперь все выглядит намного лучше: мы сначала получаем идентификатор следующего заказа, передаем его Order
в качестве аргумента конструктора, а затем сохраняем Order с помощью репозитория (см. листинг 2.22).

**Листинг 2.22:** orderEbookAction() использует nextIdentity() для предварительного определения идентификатора заказа.

```php
public function orderEbookAction(Request $request): Response
{
    // ...
    $orderId = $orderRepository−>nextIdentity();
    
    $order = new Order(
        $orderId,
        // ...
    );
    $orderRepository−>save($order);
}
// ...
```

Поскольку нам больше не нужно полагаться на save() для возврата идентификатора нового заказа, мы должны удалить тип
возвращаемого значения int из метода save() репозитория (см. листинг 2.23).

**Листинг 2.23:** метод save() теперь должен возвращать void.

```php
interface OrderRepository
{
    public function save(Order $order): void;
}
```

В качестве бонуса метод save() будет соответствовать _Command Query Separation principle_.

_Хотя этот термин был придуман Бертраном Мейером, есть полезное резюме Мартина
Фаулера: [CommandQuerySeparation](https://martinfowler.com/bliki/CommandQuerySeparation.html), . Я подробно рассматриваю
эту тему в ['Style Guide for Object Design', Manning (2019)](https://matthiasnoback.nl/book/style-guide-for-object-design/)_

### 2.6.1 Использование UUID вместо (авто)инкрементного целочисленного идентификатора
