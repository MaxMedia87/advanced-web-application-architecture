# Часть 1

### Введение

Эта часть охватывает:

* Отделение вашей модели предметной области от базы данных;
* Отделение модели чтения от модели записи (и от базы данных);
* Извлечение службы приложения из контроллера;
* Переписывание обращений к локаторам сервисов;
* Разделение вызова внешних систем на “what” and “how” вызовы;
* Инвертирование зависимостей от системных устройств для получения текущего и случайного времени.

Основная цель архитектурного стиля, предложенного в этой книге, состоит в том, чтобы провести четкое различие между
кодом ядра вашего приложения и кодом инфраструктуры, который его поддерживает. Этот так называемый инфраструктурный код
связывает основную логику вашего приложения с окружающими его системами, такими как база данных, веб-сервер, файловая
система и т. д. Оба типа кода одинаково важны, но они не должны жить вместе в одних и тех же классах. Причины для этого
будут подробно обсуждаться в заключении этой части, но краткое резюме таково: отделение ядра от инфраструктуры…

* обеспечивает прочную техническую основу для разработки с приоритетом предметной области;
* обеспечивает богатый и эффективный набор возможностей тестирования, упрощая разработку, ориентированную на
  тестирование.

Чтобы помочь вам научиться различать проблемы ядра и инфраструктуры, каждая из следующих глав начинается с некоторых
распространенных примеров «смешанного» кода в унаследованном веб-приложении. Указав на проблемы с таким кодом, мы
предпримем ряд шагов по рефакторингу, чтобы отделить основную часть от инфраструктурной. После шести таких итераций вы
познакомитесь со всеми приемами программирования, которые могут уберечь вас от смешанного кода в ваших классах. Но
прежде чем мы приступим к рефакторингу и улучшению примеров кода, давайте дадим определение терминам «ядро» и
«инфраструктурный код». Мы определим основной код, введя для него два правила. Любой другой код, который не
соответствует правилам для кода ядра, следует считать <i>кодом инфраструктуры.</i>

### 1.1 Правило №1: никаких зависимостей от внешних систем

Начнем с первого правила: код ядра не зависит напрямую ни от внешних систем, ни от кода, написанного для взаимодействия
с определенным типом внешней системы. Внешняя система — это то, что находится вне вашего приложения, например, база
данных, какой-либо удаленный веб-сервис, системные часы, файловая система и т. д. Основной код должен работать без этих
внешних зависимостей. В листинге 1.1 показано несколько методов класса, которые не следуют этому первому правилу и
поэтому должны рассматриваться как код инфраструктуры. Вы не можете вызвать ни один из этих методов без фактической
доступности их внешних зависимостей.

<b>Листинг 1.1:</b> Примеры кода, для запуска которого требуются внешние зависимости.

```php
final class NeedsExternalDependencies
{   
    /**
    * Чтобы запустить этот код, нам нужно подключение к Интернету,
    * API remoteservice.com должен быть отзывчивым.
    */
    public function callARemoteService(): void
    {
        $ch = curl_init('https://remoteservice.com/api');
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        $response = curl_exec($ch);
    }
    
    /**
     * Для запуска этого кода требуется подключение к базе данных через PDO
     * БД должна содержать таблицу под названием «orders».
     */
    public function useTheDatabase(): void
    {
      $pdo = new PDO('...');
      $statement = $pdo−>prepare('INSERT INTO orders ...');
    }
    
    /**
     * Чтобы запустить этот код, файл «settings.xml» должен существовать по указанному пути
     */
    public function loadAFile(): string
    {
        return file_get_contents(__DIR__ . '/../app/config/settings.xml');
    }
}
```

Когда код следует первому правилу, это означает, что вы можете запускать его в полной изоляции. Изоляция отлично
подходит для тестируемости. Если вы хотите написать автоматизированный тест для основного кода, это будет очень просто.
Вам не нужно настраивать базу данных, создавать таблицы, загружать приборы и т. д. Вам не потребуется подключение к
Интернету или жесткий диск с файлами на нем в определенных местах. Все, что вам нужно, это иметь возможность запускать
код и иметь доступную память компьютера.

#### 1.2 Абстракция

Как насчет метода registerUser() в листинге 1.2? Это также код инфраструктуры?

<b>Листинг 1.2:</b> Зависимость от интерфейса.

```php
interface Connection
{
  public function insert(string $table, array $data): void;
}

final class UserRegistration
{
    /**
    * @var ConnectionInterface
    */
    private $connection;
    
    public function __construct(Connection $connection)
    {
        $this−>connection = $connection;
    }

    public function registerUser(string $username, string $plainTextPassword): void 
    {
        $this−>connection−>insert(
            'users',
            [
                'username' => $username,
                'password' => $plainTextPassword
            ]
      );
    }
}
```

Метод registerUser() не использует PDO напрямую для подключения к базе данных и запуска запросов к ней. Вместо этого он
использует абстракцию для соединений с базой данных (интерфейс Connection). Это означает, что объект Connection,
внедряемый в качестве аргумента конструктора, может быть заменен более простой реализацией того же интерфейса, которому
фактически не нужна база данных (см. листинг 1.3).

<b>Listing 1.3:</b> Реализация интерфейса Connection, которой не нужна база данных.

```php
final class ConnectionDummy implements Connection
{
    /**
    * @var array<array<string,mixed>>
    */
    private array $records;
    
    /**
    * @param array<string,mixed> $data
    */
    public function insert(string $table, array $data): void
    {
        $this−>records[$table][] = $data;
    }
}
```

Это позволяет запускать код в этом методе registerUser() без необходимости запуска фактической базы данных. Делает ли
это этот код основным? Нет, потому что интерфейс Connection специально разработан для взаимодействия с реляционными
базами данных, о чем свидетельствует сама сигнатура метода insert(). Таким образом, хотя метод registerUser() напрямую
не зависит от внешней системы, он зависит от кода, написанного для взаимодействия с определенным типом внешней системы.
Это означает, что код в листинге 1.2 является кодом не ядра, а кодом инфраструктуры. Однако в целом <b>абстракция</b> —
это
решение, позволяющее избавиться от зависимостей от внешних систем. Мы обсудим несколько примеров абстракции в следующих
главах, но может быть полезно дать вам краткое изложение здесь. Создание полной абстракции для сервисов, которые
полагаются на внешние системы, состоит из двух шагов:

* Предоставьте интерфейс.
* Сообщайте о цели, а не о деталях реализации.

В качестве примера: вместо интерфейса Connection и метода insert(), что имеет смысл только в контексте работы с
реляционными базами данных, мы могли бы определить интерфейс Repository с методом save(). Такой интерфейс сообщает
цель (сохранение объектов), а не детали реализации (хранение данных в таблицах). Мы обсудим детали этого типа
рефакторинга в главе 2.

### 1.3 Правило № 2: особый контекст не требуется

Второе правило для основного кода: основной код не нуждается в определенной среде для запуска, а также не имеет
зависимостей, предназначенных для работы только в определенном контексте. В листинге 1.4 показаны некоторые примеры
кода, для запуска которого требуется специальный контекст. Предполагается, что определенные вещи были настроены или что
он работает внутри определенного типа приложения, такого как веб-приложение или приложение командной строки (CLI).

<b>Листинг 1.4:</b> Примеры кода, для запуска которого требуется специальный контекст.

```php
final class RequiresASpecialContext
{
    public function usesGlobalState(): void
    {
        /*
         * Здесь мы полагаемся на глобальное состояние и предполагаем, 
         * что этот метод выполняется как часть HTTP-запроса.
        */
        $host = $_SERVER['HTTP_HOST'];
    }
    // ...
    public function usesAStaticServiceLocator(): void
    {
        /*
        * Здесь мы полагаемся на то, что Zend_Registry был настроен до вызова этого метода.
        */
        $translator = Zend_Registry::get('Zend_Translator');
    }
    // ...
    public function onlyWorksAtTheCommandLine(): void
    {
        /*
        * Здесь мы полагаемся на 'php_sapi_name()', чтобы вернуть определенное значение.
        * Только когда это приложение будет запущено из командной строки, эта функция вернет «cli».
        */
        if (php_sapi_name() !== 'cli') {
            return;
        }
    }
}
// ...
```

Некоторый код теоретически может работать в любой среде, но на практике это будет неудобно. Рассмотрим пример в листинге
1.5. Экземпляр OrderController может быть создан в любом контексте, и было бы относительно легко вызвать метод действия
и передать ему экземпляр RequestInterface. Однако ясно, что этот код был разработан для работы только в очень
специфической среде, а именно в веб-приложении.

<b>Листинг 1.5:</b> Код, предназначенный для работы в веб-приложении.

```php
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

final class OrderController
{
    public function createOrderAction(RequestInterface $request): ResponseInterface 
    {
    // ...
    }
}
```

Только если код не требует специального контекста, а также не предназначен для работы в специальном контексте или имеет
зависимости, для которых это имеет место, он может считаться базовым кодом. В листинге 1.6 показано несколько примеров
основного кода. Эти классы могут быть созданы где угодно, и любой клиент должен иметь возможность вызывать любой из
доступных методов. Ни один из этих методов не зависит ни от чего вне самого приложения.

<b>Листинг 1.6:</b> Несколько примеров основного кода.

```php
/**
* Это правильная абстракция для объекта, который взаимодействует с базой данных.
 */
interface MemberRepository
{
    public function save(Member $member): void;
}

final class MemberService
{
    private MemberRepository $memberRepository;
    
    public function requestAccess(
            string $emailAddress,
            string $purchaseId
    ): void {
        $member = Member::requestAccess(
            EmailAddress::fromString($emailAddress),
            PurchaseId::fromString($purchaseId)
        );
        
        $this−>memberRepository−>save($member);
    }
}

final class EmailAddress
{
    private string $emailAddress;
    
    private function __construct(string $emailAddress)
    {
        if (!filter_var($emailAddress, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidArgumentException('...');
        }
        
        $this−>emailAddress = $emailAddress;
    }
    
    public static function fromString(string $emailAddress): self
    {
        return new self($emailAddress);
    }
}

final class Member
{
    public static function requestAccess(
        EmailAddress $emailAddress,
        PurchaseId $purchaseId
    ): self {
    // ...
    }
}
```

Отсутствие необходимости создавать специальный контекст для запуска кода, опять же, отлично подходит для тестируемости.
Единственное, что вам нужно сделать в тестовом сценарии, — это создать экземпляр класса и вызвать для него метод. Но
соблюдение правил для основного кода полезно не только для тестирования. Это также помогает защитить ваш основной код от
всех видов внешних изменений, таких как серьезное обновление инфраструктуры, переход на другого поставщика базы данных и
т. д.

Не случайно классы в этом примере ориентированы на предметную область. В главе 12 мы обсудим архитектурные уровни
и определим правила для уровней предметной области и приложений, которые естественным образом согласуются с правилами
для кода ядра и инфраструктуры. Короче говоря: весь код предметной области и варианты использования приложения должны
быть основным кодом, а не полагаться или быть связанным с окружающей инфраструктурой.

Это также объясняет, почему я
использую слова «ядро» и «инфраструктура». Инфраструктура — это общий термин, используемый для описания технических
аспектов взаимодействия. В веб-приложении инфраструктура поддерживает связь между вашим приложением и внешним миром.
Ядро — это центр вашего приложения, вокруг него находится инфраструктура, защищающая ядро и соединяющая его с внешними
системами и пользователями (рис. 1.1).

![Изображение](/images/01.png)

Рисунок 1.1: Подключение ядра к внешним системам и пользователям через инфраструктуру

«Является ли весь код в директории /vendor кодом инфраструктуры?»

Отличный вопрос. В /vendor вы найдете свой
веб-фреймворк, который облегчает связь с браузерами и внешними системами по протоколу HTTP. Вы также найдете ORM,
который упрощает связь с базой данных и помогает сохранять объекты в таблицах. Весь этот код не соответствует
определению основного кода, данному в этой главе. Для запуска этого кода обычно требуются внешние системы, такие как
база данных или веб-сервер. Код был разработан для работы в определенном контексте, таком как терминал, или как часть
цикла веб-запроса/ответа. Таким образом, большую часть кода в /vendor следует считать кодом инфраструктуры. Однако
нахождение в конкретном каталоге не определяет, является ли что-то кодом инфраструктуры. В правилах об этом ничего не
сказано. Важно то, что делает код и что ему для этого нужно. Это означает, что часть или, может быть, большая часть кода
в /vendor все-таки может считаться основным кодом, даже если он написан не вами и не специально для вашего приложения.

### 1.4. Резюме

На протяжении всей этой книги мы проводим различие между кодом ядра и кодом инфраструктуры, что позже станет
основой для некоторых архитектурных решений.

<b>Основной код</b> — это код, который может выполняться в любом контексте, без
какой-либо специальной настройки или внешних систем, которые должны быть доступны.

<b>Для кода инфраструктуры все наоборот:</b>
ему нужны внешние системы, специальная настройка или он предназначен для работы только в определенном контексте. В
следующих главах мы рассмотрим, как провести рефакторинг смешанного кода, чтобы правильно разделить код ядра и
инфраструктуры в соответствии с правилами, изложенными в этой главе.

### Упражнения

<b>Вопрос:</b>
Следует ли считать приведенный ниже код инфраструктурным кодом?

```php
$now = new DateTimeImmutable('now');
$expirationDate = $now−>modify('+2 days');
$membershipRequest = new MembershipRequest($expirationDate);
```

<b>Ответ:</b>
Да. Чтобы определить текущее время, приложение обращается к окружающей инфраструктуре, в данном случае к системному классу DateTimeImmutable.

<b>Вопрос:</b>
Следует ли считать приведенный ниже код инфраструктурным кодом?

```php
namespace Symfony\Component\EventDispatcher;
    
class EventDispatcher implements EventDispatcherInterface
{
    public function dispatch(
        object $event,
        string $eventName = null
    ): object {
        $eventName = $eventName ?? get_class($event);
        
        if ($listeners) {
            $this−>callListeners($listeners, $eventName, $event);
        }
        
        return $event;
    }
}
```

<b>Ответ:</b>
Нет. Несмотря на то, что код является частью фреймворка Symfony, для его запуска не требуется никакой специальной
настройки. Он не требует наличия внешних систем и не предназначен для работы в определенном контексте, таком как
терминал или веб-сервер.

<b>Вопрос:</b>
Следует ли считать приведенный ниже код основным кодом?

```php
interface HttpClient
{
    public function get(string $url): Response;
}

final class Importer
{
    private HttpClient $httpClient;
    
    public function __construct(HttpClient $httpClient)
    {
        $this−>httpClient = $httpClient;
    }
    
    public function importPurchasesFromLeanpub(): void
    {
        $response = $this−>httpClient−>get('https://leanpub.com/api/individual−purchases');
    }
}
```

<b>Ответ:</b>
Нет. Несмотря на то, что код зависит от интерфейса, абстракция зависимости не является полной. Интерфейс HttpClient
предназначен для связи с внешними службами на основе HTTP и не может быть заменен разумной альтернативой, в случае если
HTTP
больше не является поддерживаемой технологией.