### Глава 3. Модели чтения и представления (Read and View models)

Эта глава охватывает:

* Создание новой модели только для получения информации.
* Различные решения для реализации репозитория модели чтения.
* Сокрытие сложности запроса за моделями представления (особый вид моделей чтения).

В предыдущей главе мы избавились от двух из трех SQL-запросов, которые изначально были внутри контроллера:

* Мы переместили запрос INSERT INTO Orders в SqlOrderRepository.
* Мы избавились от запроса SELECT LAST_INSERT_ID(), используя собственный механизм генерации идентификатора.

Оставшийся SQL-запрос выполняет поиск в таблице **ebooks**, чтобы узнать цену электронной книги, которую пользователь
выбрал для покупки (листинг 3.1).

**Листинг 3.1:** Один оставшийся SQL-запрос внутри контроллера.

```php
public function orderEbookAction(Request $request): Response
{
    $connection = $this−>container−>get('connection');
    $ebookPrice = $connection−>execute(
        'SELECT price FROM ebooks WHERE id = :id',
        [
            'id' => $request−>request−>get('ebook_id')
        ]
    )−>fetchColumn(0);
    
    $orderAmount = (int)$request−>get('quantity') * (int)$ebookPrice;
    // Сохранение заказа (Глава 1)
    // ...
    
    return new Response(/* ... */);
}
```

По тем же причинам, о которых мы говорили в предыдущей главе, мы хотели бы иметь лучший способ представить этот важный
этап сценария; узнать цену электронной книги. Мы хотим скрыть низкоуровневые детали реализации (реляционная база данных,
таблица электронных книг, столбец цен и т. д.) за высокоуровневым интерфейсом, который представляет, какая информация
нас интересует, а не то, как система извлекает эту информацию. Может быть, мы можем применить тот же вид рефакторинга,
что и в [Главе 2](chapter-2.md)? То есть введите Entity для представления электронной книги и извлечения ее из
репозитория.

### 3.1 Повторное использование модели записи

Предположим, что у нас уже есть такой объект Ebook и интерфейс EbookRepository в нашем проекте, как показано в листинге
3.2. До сих пор эти классы использовались внутри EbookController только для добавления новой электронной книги в каталог
или для изменения ее сведений.

**Листинг 3.2:** Объект Ebook и интерфейс EbookRepository.

```php
final class Ebook
{
    private EbookId $ebookId;
    private int $price;
    // ...
    public function __construct(
        EbookId $ebookId,
        int $price
        // ...
    ) {
        $this−>ebookId = $ebookId;
        $this−>price = $price;
    }
    
    // ...
    public function changePrice(int $newPrice): void
    {
        $this−>price = $newPrice;
    }
    
    public function show(): void
    {
        // ...
    }
    
    public function hide(): void
    {
        // ...
    }
}

// More actions...
interface EbookRepository
{
    /**
    * @throws CouldNotFindEbook
    */
    public function getById(EbookId $ebookId): Ebook;
    
    /**
    * @throws CouldNotSaveEbook
    */
    public function save(Ebook $ebook): void;
}
```

Теперь давайте выясним, можем ли мы использовать эту сущность электронной книги в процессе заказа, когда нам нужно
узнать цену электронной книги. Самое простое, что мы можем сделать, это добавить к объекту метод getPrice(). Это
позволяет сразу же использовать его внутри orderEbookAction() . В листинге 3.3 показано, как контроллер извлекает нужный
объект электронной книги из EbookRepository на основе идентификатора, предоставленного пользователем при отправке
HTML-формы.

**Листинг 3.3:** Использование объекта Ebook внутри OrderController.

```php
public function orderEbookAction(Request $request): Response
{
    $ebook = $this−>ebookRepository−>getById(
        EbookId::fromString($request−>request−>get('ebook_id'))
    );
    
    $ebookPrice = $ebook−>getPrice();
    $orderAmount = (int) $request−>get('quantity') * (int)$ebookPrice;
    // Сохранение заказа (Глава 1)
    // ...
    
    return new Response(/* ... */);
}
```

Это решение выглядит хорошо. Существующая сущность Ebook является удобным объектом для быстрого получения информации,
поскольку она уже содержит эту информацию в своем поле $price. Однако есть несколько проблем с повторным использованием
существующей сущности в другом контексте.

Во-первых, существующий объект не предназначен для извлечения информации. Мы
используем его для добавления новых электронных книг в наш каталог. Когда мы хотим временно удалить его из каталога, но
не хотим удалять на самом деле, мы вызываем его метод hide() и сохраняем его снова. Все остальное, что мы делаем с этой
сущностью электронной книги, связано с изменениями состояния, и когда бы мы ни загружали сущность, мы делаем это с
намерением манипулировать ею и сохранять ее. Но теперь мы начали использовать Ebook в createOrderAction(), где вообще не
хотим ничего менять. Мы просто хотим получить от него немного информации, и по этой причине нам пришлось добавить метод
getPrice(). Однако, получая полный объект Ebook, мы получаем доступ ко всем этим методам, которые могут изменить
состояние объекта, таким как changePrice() и hide(). Как правило, разумной идеей является ограничение количества
методов, к которым имеет доступ клиент объекта. Тем более, если эти методы имеют побочные эффекты, такие как изменение
состояния. В этой ситуации мы также, вероятно, не должны использовать объект Ebook, когда нам нужна только информация,
но мы никогда не хотим ее менять.

Другая проблема связана с повторным использованием объектов в целом, а не только сущностей. Если вы начнете повторно
использовать объект в разных местах и по разным причинам, объект начнет играть слишком много ролей одновременно. Чем
больше ролей должен играть объект, тем больше методов и, следовательно, строк кода он будет содержать. Вскоре он
становится слишком большим, чтобы читать код и понимать, что он делает, не говоря уже о том, чтобы вносить в него
изменения. Когда методы вызывают друг друга или когда они полагаются на одни и те же свойства объекта, изменить что-либо
в этом будет действительно сложно. Поскольку многие клиенты теперь используют объект, они полагаются на то, что его
поведение останется прежним. Будет трудно оценить, безопасно ли внесение изменений, и не нарушат ли они работу одного из
своих клиентов, который все еще полагается на какое-то недокументированное существующее поведение. Такой объект
становится устойчивым к изменениям, что является плохим качеством для объектов вообще. Вы, вероятно, знаете эту цепочку
событий: так создается унаследованный код.

Конечно, без повторного использования разработчику программного обеспечения было бы очень трудно добиться чего-либо
вообще. Но хотя бы следите за предполагаемым использованием предметов и следите за напряжением в дизайне. Когда два
клиента используют объект, вскоре он будет привлекать поведение, которое имеет отношение только к одному из его
клиентов. Или клиент может получить доступ к знаниям, которых у него быть не должно. По моему опыту, вы можете
предотвратить большую часть этого напряжения дизайна, введя отдельные объекты для изменения информации и извлечения
информации. Или, как это традиционно называется: отделение вашей модели записи от модели чтения. Клиент, которому нужен
объект для получения информации (чтение), не должен извлекать тот же объект, что и клиенты, которые хотят внести в него
изменения (запись).

Хотя текущая версия нашего контроллера еще не испытывает больших проблем, мы теперь совмещаем запись и чтение в одном и
том же объекте, так что мы могли бы пойти дальше и предотвратить проблемы, используя отдельные объекты для изменения
состояния и получения информации. Это означает, что мы оставляем сущность электронной книги как есть и создаем новый
объект, модель чтения электронной книги, которая служит для местной потребности - знать цену электронной книги. Эта
модель чтения электронных книг будет объектом только для чтения (также известным как неизменяемый объект (_Immutable
Object_)).
Клиенты, имеющие доступ к модели чтения, не смогут (случайно) изменить ее состояние.

«Запрещены ли геттеры в сущностях?»

Я пытался прояснить, что сущность не должна использоваться там, где необходима
информация. Добавление геттера к объекту часто является признаком того, что вы загрузили объект только для того, чтобы
получить от него данные. Вам следует подумать о введении модели чтения в таком сценарии, как мы собираемся сделать в
следующем разделе. Это не означает, что вы никогда не сможете добавить геттер к объекту. Обычно мне нужен как минимум
геттер для идентификатора объекта и геттер для извлечения записанных внутри событий (мы поговорим об этом в Разделе
3.3.2). В зависимости от вашей ситуации может быть и другая информация, которую сущность должна раскрывать. Но всегда
рассматривайте и альтернативные конструкции. Вот пример из предыдущего проекта, где объекту был предоставлен
дополнительный геттер для раскрытия его «периода резервирования»:

```php
// $vatReturn — сущность, $bookingPeriods — сервис.
/** 
 * Нам нужно убедиться, что период бронирования декларации по НДС еще не закрыт, 
 * прежде чем мы попытаемся откатить ее.
 */
if ($bookingPeriods−>isClosed($vatReturn−>bookingPeriod()) {
    throw CouldNotRollBack::becauseBookingPeriodIsClosed();
}

$vatReturn−>rollBack();
```

Это альтернативная реализация, в которой объекту не нужен геттер:

```php
$vatReturn−>rollBack($bookingPeriods);

// Внутри объекта:
public function rollBack(BookingPeriods $bookingPeriods): void
{
    if ($bookingPeriods−>isClosed($this−>bookingPeriod) {
        throw CouldNotRollBack::becauseBookingPeriodIsClosed();
    }
}
// ...
```

Независимо от альтернатив дизайна и эмпирических правил, не нужно бояться геттеров.
И уж точно не запрещены.

### 3.2 Создание отдельной модели чтения

В любой ситуации, когда вам нужна информация, вы можете ввести модель чтения. Вы формулируете вопрос таким образом,
чтобы вам было легко его задать, и вы разрабатываете тип ответа, который хотите получить. В нашем случае вопрос был бы
таким: дайте мне цену электронной книги с ID […]. Ответом будет объект, представляющий цену электронной книги.

Обычно есть два варианта моделирования вопроса с помощью кода. Вы можете использовать шаблон репозитория еще раз и
создать классы с теми же или похожими именами, что и сами классы сущностей (см. листинг 3.4). В этом случае вы должны
поместить код в другое пространство имен, чтобы упростить отличие модели чтения и записи.

**Листинг 3.4.** Модель чтения электронных книг и интерфейс репозитория модели чтения.

```php
interface EbookRepository
{
    /**
    * @throws CouldNotFindEbook
    */
    public function getById(EbookId $ebookId): Ebook;
}

final class Ebook
{
    private EbookId $ebookId;
    private int $price;
    /**
    * @internal Only to be used by implementations of 'EbookRepository'
    */
    public function __construct(
        EbookId $ebookId,
        int $price
    ) {
        $this−>ebookId = $ebookId;
        $this−>price = $price;
    }

    public function price(): int
    {
        return $this−>price;
    }
}

// использование в контроллере:
$ebook = $this−>ebookRepository−>getById(
    EbookId::fromString($request−>request−>get('ebook_id'))
);

$ebookPrice = $ebook−>price();
```

Этот подход полезен, если вы хотите получить более одной части информации, или вы уверены, что захотите сделать это в
ближайшем будущем. Например, допустим, вам также нужно название электронной книги, чтобы сохранить его в самом Заказе.
Тогда имеет смысл повторно использовать ту же модель чтения электронных книг и добавить к ней метод title(), чтобы мы
могли получить и название, и цену из одного и того же объекта. С другой стороны, если вам нужна только одна часть
информации, вы можете отказаться от псевдосущности. Интерфейс может иметь метод, который напрямую возвращает нужные вам
данные. В листинге 3.5 показано, как это может привести к классу модели чтения ( Price ) и интерфейсу с методом для
получения одной цены (в настоящее время представленной в виде целого числа) на основе EbookId .

**Листинг 3.5:** Модель чтения электронных книг и интерфейс репозитория.

```php
interface GetPrice
{
    /**
    * @throws CouldNotFindEbook
    */
    public function ofEbook(EbookId $ebookId): int;
}

// использование в контроллере:
$ebookPrice = $this−>getPrice−>ofEbook(
    EbookId::fromString($request−>request−>get('ebook_id'))
);
```

Как видно из примера использования, второй подход может привести к тому, что код будет приятнее для чтения (или более
экзотическим, в зависимости от вашего вкуса). Но следует ли вам использовать первый или второй подход, зависит от вашей
ситуации.

### 3.3 Реализация репозитория модели чтения

Пока давайте остановимся на первом варианте: модель чтения электронных книг и интерфейс EbookRepository. Всякий раз,
когда администратор создает новую сущность электронной книги, также должен быть соответствующий объект модели чтения
электронной книги, который может показывать цену электронной книги клиентам, которым нужна эта информация. Всякий раз,
когда объект изменяется, соответствующая модель чтения также должна обновляться, чтобы отражать эти изменения.

#### 3.3.1 Совместное использование базового источника данных

Самым простым решением для согласования записи с моделью чтения было бы позволить модели чтения использовать базовый
источник данных сущности. В нашем случае данные объекта Ebook будут сохранены в таблице ebooks. Мы могли бы предоставить
реализацию интерфейса репозитория модели чтения, которая получает данные из той же самой таблицы (см. листинг 3.6).

**Листинг 3.6.** Создание объекта модели чтения электронной книги из источника данных объекта.

```php
final class SqlEbookRepository implements EbookRepository
{
    private Connection $connection;

    public function __construct(Connection $connection)
    {
        $this−>connection = $connection;
    }
    
    public function getById(EbookId $ebookId): Ebook
    {
        $record = $this−>connection−>execute(
            'SELECT price FROM ebooks WHERE id = ?',
            [
                $ebookId−>asString()
            ]
        )−>fetchAssoc();
        
        if ($record === false) {
            throw CouldNotFindEbook::withId($ebookId);
        }
        
        return new Ebook(
            $ebookId,
            (int)$record['price']
        );
    }
}
```

Хотя это удобное решение, когда модель записи и чтения использует один и тот же источник данных, это может привести к
новым проблемам. Может случиться так, что репозиторий модели чтения интерпретирует данные иначе, чем модель записи. Даже
в приведенном выше примере предполагается, что столбец цены содержит цену электронной книги в центах. Что, если в
какой-то момент модель записи переключится на собственное десятичное представление. Модель чтения начнет давать плохие
цены, потому что 1,50 евро в базе данных при приведении к целому числу станут 1 центом в приложении. Один из способов
снизить этот риск — написать интеграционные тесты для репозиториев моделей чтения. Еще одна вещь, которую вы могли бы
сделать, чтобы улучшить ситуацию, — это реализовать в одном классе интерфейс репозитория модели для записи и чтения.
Таким образом, информация о таблице базы данных и значении ее столбцов находится по крайней мере в одном месте, что
снижает вероятность того, что вы столкнетесь с такой проблемой.

